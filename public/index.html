<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 40px;
      }

      h1, p {
        text-align: center;
      }

      .filters {
        display: flex;
        justify-content: center; /* Center horizontally */
        align-items: center;     /* Align vertically */
        gap: 15px;               /* Add space between inputs and buttons */
        margin: 20px 0;          /* Add spacing above and below the bar */
        flex-wrap: wrap;         /* Allow items to wrap on small screens */
      }

      .chart-container {
        max-width: 800px;
        margin: 0 auto;
      }
    </style>
    <title>Birdcage Status</title>
  </head>
  <body>
    <h1 id="heading">Birdcage Monitor</h1>
    <p>Status of temperature and humidity.</p>
    <div class="filters">
      <label>Select Date:
        <input type="date" id="dateFilter">
      </label>
      <label>Room:
        <select id="roomFilter">
        </select>
      </label>
      <button onclick="loadTemperatureData()">Query</button>
      <button onclick="resetFilters()">Reset</button>
    </div>
    <div class="chart-container">
      <canvas id="temperatureChart"></canvas>
    </div>
  <script>
let chartInstance = null;
let roomMap = {};

async function loadRooms() {
  try {
    const response = await fetch('rooms');
    if (!response.ok) throw new Error('Failed to fetch rooms');

    const rooms = await response.json();
    rooms.forEach(r => { roomMap[r.id] = r.name; });
    const select = document.getElementById('roomFilter');

    // Reset to just the default option
    select.innerHTML = '<option value="">All Rooms</option>';

    rooms.forEach(room => {
      const option = document.createElement('option');
      option.value = room.id;       // The value sent to the backend
      option.textContent = room.name; // The text shown to the user
      select.appendChild(option);
    });

  } catch (error) {
    console.error("Error loading room list:", error);
  }
}

async function loadTemperatureData() {
  const dateFilter = document.getElementById('dateFilter').value;
  const roomFilter = document.getElementById('roomFilter').value;

  let url = 'temp';
  const params = new URLSearchParams();

  if (roomFilter) params.append('room_id', roomFilter);

  if (dateFilter) {
    const startDate = new Date(dateFilter + 'T00:00:00');
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + 1);

    params.append('start_time', startDate.toISOString());
    params.append('end_time', endDate.toISOString());
  }

  if (params.toString()) {
    url += '?' + params.toString();
  }

  try {
    const response = await fetch(url);
    const result = await response.json();

    if (result.success) {
      if (result.data.length === 0) {
          alert("No data found for this period.");
      }
      renderChart(result.data);
    } else {
      alert(result.error || "Unknown error occurred");
    }
  } catch (error) {
    console.error(error);
  }
}

function resetFilters() {
  const today = new Date().toISOString().split('T')[0];
  document.getElementById('dateFilter').value = today;
  document.getElementById('roomFilter').value = '';
  loadTemperatureData();
}

function renderChart(data) {
  const rooms = {};
  data.forEach(record => {
    if (!rooms[record.room_id]) {
      rooms[record.room_id] = [];
    }

    // Treat database string as UTC so it converts to browser Local Time
    // e.g. "2023-11-30 12:00:00" -> "2023-11-30T12:00:00Z"
    const dateObj = new Date(record.recorded_at.replace(" ", "T") + "Z");

    rooms[record.room_id].push({
      time: dateObj.toLocaleTimeString(),
      temperature: record.temperature,
      humidity: record.humidity
    });
  });

  const ctx = document.getElementById('temperatureChart').getContext('2d');

  if (chartInstance) {
    chartInstance.destroy();
  }

  const colorPalette = [
    { temp: 'rgb(255, 99, 132)',  humid: 'rgb(54, 162, 235)' }, // Red / Blue
    { temp: 'rgb(255, 159, 64)',  humid: 'rgb(75, 192, 192)' }, // Orange / Teal
    { temp: 'rgb(153, 102, 255)', humid: 'rgb(46, 204, 113)' }, // Purple / Green
  ];

  const datasets = [];

  Object.keys(rooms).forEach((roomId, index) => {
    const roomData = rooms[roomId];

    // Pick a style pair based on index (cycles if you have many rooms)
    const style = colorPalette[index % colorPalette.length];

    // 1. Temperature Dataset (Warm Color, Solid Line)
    const labelName = roomMap[roomId] || `Room ${roomId}`;
    datasets.push({
      label: `${labelName} Temp`,
      data: roomData.map(r => ({x: r.time, y: r.temperature})),
      borderColor: style.temp,      // Set Temp color
      backgroundColor: style.temp,
      tension: 0.1,
      yAxisID: 'y',
    });

    // 2. Humidity Dataset (Cool Color, Dashed Line)
    datasets.push({
      label: `${labelName} Humidity`,
      data: roomData.map(r => ({x: r.time, y: r.humidity})),
      borderColor: style.humid,     // Set Humidity color
      backgroundColor: style.humid,
      tension: 0.1,
      yAxisID: 'y1',
      pointStyle: 'rect'
    });
  });

  chartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: datasets
    },
    options: {
      responsive: true,
      interaction: {
        mode: 'index',
        intersect: false,
      },
      scales: {
        x: {
          type: 'category',
          title: { display: true, text: 'Time' }
        },
        y: {
          type: 'linear',
          display: true,
          position: 'left',
          title: { display: true, text: 'Temperature (Â°C)' }
        },
        y1: {
          type: 'linear',
          display: true,
          position: 'right',
          title: { display: true, text: 'Humidity (%)' },
          grid: {
            drawOnChartArea: false,
          },
        }
      }
    }
  });
}

loadRooms();
loadTemperatureData();
  </script>
  </body>
</html>
